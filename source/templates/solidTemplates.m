function Phi=solidTemplates(shapeString,opts)
arguments
    shapeString (1,1) string;
    opts.L {mustBeNumeric} = 1;
    opts.nX  {mustBeNumeric} = 20;
    opts.robinCoeff {mustBeNumeric} = 0;
    opts.Discretization {mustBeNonzeroLengthText, mustBeMember(opts.Discretization,{'Uniform','Chebyshev'})} = 'Uniform';
end

switch shapeString
    case 'tetrahedron'
        nodes = [...
            0 0 0 ; ...
            1 1 0; ...
            1 0 1; ...
            0 1 1];
        edges = [1 2;1 3;1 4;2 3;3 4;4 2];
    case 'cube'
        nodes = [...
            0 0 0; ...
            1 0 0; ...
            0 1 0; ...
            1 1 0; ...
            0 0 1; ...
            1 0 1; ...
            0 1 1; ...
            1 1 1];
        edges = [1 2;1 3;1 5;2 4;2 6;3 4;3 7;4 8;5 6;5 7;6 8;7 8];
    case 'octahedron'
        nodes = [1 0 0;...
            0 1 0;...
            -1 0 0;...
            0 -1 0;...
            0 0 1;...
            0 0 -1];
        edges = [1 2;1 4;1 5; 1 6;2 3;2 5;2 6;3 4;3 5;3 6;4 5;4 6];
    case 'dodecahedron'
        [nodes,edges] = dodecahedron();
    case 'icosahedron'
        [nodes,edges] = icosahedron();
    case 'cuboctahedron'
        nodes = [...
            0 -1 1;1 0 1;0 1 1;-1 0 1; ...
            1 -1 0;1 1 0;-1 1 0;-1 -1 0;...
            0 -1 -1;1 0 -1;0 1 -1;-1 0 -1];
        
        edges = [...
            1  2;  1  4; 1 5; 1 8; ...
            2  3;  2  5; 2 6; ...
            3  4;  3  6; 3 7; ...
            4  7;  4  8; ...
            5  9;  5 10; ...
            6 10;  6 11; ...
            7 11;  7 12; ...
            8  9;  8 12; ...
            9 10;  9 12; ...
            10 11; 11 12];
    case 'buckyball'
        [nodes,edges] = buckyball();
    otherwise
        error('geom3Dtemplate:wrongShape','Not a valid geom3d shape');
end
nodes=nodes-mean(nodes,1); % Recenter the vertices so their center of mass is at the origin
source = edges(:,1);
target = edges(:,2);
L = norm(nodes(target(1),:)-nodes(source(1),:));
LVec = opts.L*ones(length(edges),1);
nodes = nodes*opts.L/L;

Phi = quantumGraph(source, target,LVec,'nxVec',opts.nX,'robinCoeff',opts.robinCoeff,'Discretization',opts.Discretization);

plotCoordFcn=@(G)plotCoordFcnFromNodes(G,nodes);

Phi.addPlotCoords(plotCoordFcn);

end

function [nodes,edges]=icosahedron()
theta = 2*pi/5;
l = 1/sin(theta/2)/2;
z1 = sqrt(1-l*l);

t1 = (0:2*pi/5:2*pi*(1-1/5))';
x1 = l*cos(t1);
y1 = l*sin(t1);

t2 = t1 + 2*pi/10;
x2 = l*cos(t2);
y2 = l*sin(t2);

h = sqrt(l*l-.5*.5);
z2 = sqrt(3/4 - (l-h)*(l-h));

% Create mesh data

nodes = [0 0 0;...
    [x1 y1 repmat(z1, [5 1])]; ...
    [x2 y2 repmat(z1+z2, [5 1])]; ...
    0 0 2*z1+z2];

edges = [...
    1 2;...
    1 3;...
    1 4;...
    1 5;...
    1 6; ...
    2 3;...
    2 7;...
    3 4;...
    3 8;...
    4 5;...
    4 9;...
    5 6;...
    5 10;...
    6 2; ...
    6 11;...
    7 3;...
    7 8;...
    7 12;...
    8 4;...
    8 9;...
    8 12;...
    9 5;...
    9 10;...
    9 12;...
    10 6;...
    10 11;...
    10 12;
    11 2; ...
    11 7; ...
    11 12];
end

function [nodes,edges]=dodecahedron()
% golden ratio
phi = (1+sqrt(5))/2;

% coordinates pre-computations
b = 1 / phi ;
c = 2 - phi ;

% use values given by P. Bourke, see:
% http://local.wasp.uwa.edu.au/~pbourke/geometry/platonic/
tmp = [ ...
    c  0  1 ;   b  b  b ;   0  1  c  ; -b  b  b  ; -c  0  1 ;  ...
    -c  0  1 ;  -b -b  b ;   0 -1  c  ;  b -b  b  ;  c  0  1 ;   ...
    c  0 -1 ;   b -b -b ;   0 -1 -c  ; -b -b -b  ; -c  0 -1 ;  ...
    -c  0 -1 ;  -b  b -b ;   0  1 -c  ;  b  b -b  ;  c  0 -1 ; ...
    0  1 -c ;   0  1  c ;   b  b  b  ;  1  c  0  ;  b  b -b ; ...
    0  1  c ;   0  1 -c ;  -b  b -b  ; -1  c  0  ; -b  b  b ; ...
    0 -1 -c ;   0 -1  c ;  -b -b  b  ; -1 -c  0  ; -b -b -b ; ...
    0 -1  c ;   0 -1 -c ;   b -b -b  ;  1 -c  0  ;  b -b  b ; ...
    1  c  0 ;   b  b  b ;   c  0  1  ;  b -b  b  ;  1 -c  0 ;  ...
    1 -c  0 ;   b -b -b ;   c  0 -1  ;  b  b -b  ;  1  c  0 ; ...
    -1  c  0 ;  -b  b -b ;  -c  0 -1  ; -b -b -b  ; -1 -c  0 ; ...
    -1 -c  0 ;  -b -b  b ;  -c  0  1  ; -b  b  b  ; -1  c  0 ;  ...
    ];

% extract coordinates of unique vertices
[nodes, M, N] = unique(tmp, 'rows', 'first'); %#ok<ASGLU>

% compute indices of face vertices, put result in a 12-by-5 index array
ind0 = reshape((1:60), [5 12])';
faces = N(ind0);

% extract edges from faces
edges = [reshape(faces(:, 1:5), [60 1]) reshape(faces(:, [2:5 1]), [60 1])];
edges = unique(sort(edges, 2), 'rows');
end

function [nodes,edges]= buckyball()

[b, nodes] = bucky;

% compute edges
[i, j] = find(b);
edges = [i j];
edges = unique(sort(edges, 2), 'rows');
end

